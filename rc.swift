#!/usr/bin/env xcrun --sdk macosx swift
import Foundation

func ==(lhs: LKey, rhs: LKey) -> Bool {
    return lhs.c == rhs.c
}

struct LKey: Hashable {
    var o: String // original
    var c: String // converted
    var hashValue: Int {
        return c.hash
    }
}

func isSpecialKey(part: String) -> Bool {
    let special = [] // add any special prefixed keys e.g CV_KEY_...
    return special.map{"\"\($0)"}.filter{part.hasPrefix($0)}.count > 0
}

func stripLocalized(_ str: String, second: Bool = false ) -> String {
    let range = Range(uncheckedBounds: (lower: str.index(str.startIndex, offsetBy: 1), upper: str.index(str.endIndex, offsetBy: second ? -2 : -1)))
    let stripped = str.substring(with: range)
    return stripped
}

private let NL = "\n"; private let Space = " "

let fileManager = FileManager.default
let path = fileManager.currentDirectoryPath
print(path)

var localizedStrings: [LKey] = []
if let str = try? String(contentsOfFile: path + "/en.lproj/Localizable.strings") {
    //  let str = String(data: data, encoding: .utf8)!
    let localizedArray: [LKey]? = str.components(separatedBy: CharacterSet.newlines).flatMap{LKey(o: $0, c: $0)}.filter{$0.o.characters.count > 0}
    let anotherfilter = localizedArray!.filter{$0.o.components(separatedBy: "=").count == 2}
    // get a line
    for line in anotherfilter {  // split it i
        let parts = line.o.components(separatedBy: "=")
        let firstpart =  parts.first?.trimmingCharacters(in: CharacterSet.whitespaces)  ?? ""
        let secondpart = parts.last?.trimmingCharacters(in: CharacterSet.whitespaces)  ?? ""
        let isSpecial = isSpecialKey(part:firstpart)
        let chosenPart =  firstpart
        // get it off the "" and or ;
        let stripped = stripLocalized(chosenPart, second: false)
        let lkey = LKey(o:  stripped, c:  stripped)
        localizedStrings.append(lkey)
        if isSpecial {
            let stripped = stripLocalized(secondpart, second: true)
            let lkey = LKey(o: stripped, c:  stripped)
            localizedStrings.append(lkey)
        }
    }
} else {
    print("oOoOoOOoOoh shit")
}

// MARK: -   Legalize

// legalize
var prepared: [LKey] = []

func capitalize(str: LKey, where separator: String) -> LKey {
    let sepSpace = str.c.components(separatedBy: separator).map{$0.capitalized}
    return sepSpace.count > 1 ? LKey(o:str.o,c:sepSpace.joined()) : str
}

func trimAnynotAllowedCharsFromPrefix(str: LKey)  -> LKey {
    var key = str
    guard key.c.characters.count > 0 else {
        return key
    }
    if let _r = key.c.rangeOfCharacter(from: CharacterSet.letters) {
        key = LKey(o: str.o, c: str.c.substring(from: _r.lowerBound))
    } else {
        key = LKey(o: str.o, c: "XNOTXVALIDX")
    }
    return key
}

func checkValid(str: LKey) -> Bool {
    return str.c != "XNOTXVALIDX"
}

func prepare(str: LKey) -> LKey {
    let phase1 = capitalize(str: str, where: " ")
    let p2 = capitalize(str: phase1, where: "_")
    let p3 = capitalize(str: p2, where: "-")
    let p4 = capitalize(str: p3, where: ".")
    return p4
}

func removeEspecialChars(str: LKey) -> LKey {
    let specialchars = ["&","*","@","!","(",")","#",",","/","?"]
    var trimmed = str.c
    specialchars.forEach({trimmed = trimmed.replacingOccurrences(of: $0, with: "")})
    return LKey(o: str.o, c: trimmed)
}
func removeEspecialwords(str: LKey) -> LKey {
    let specialchars = ["NO":"no","YES":"yes"]
    var trimmed = str.c
    specialchars.forEach { (k,v) in
        trimmed = trimmed.replacingOccurrences(of: k, with: v)
    }
    return LKey(o: str.o, c: trimmed)
}

prepared = localizedStrings.map(trimAnynotAllowedCharsFromPrefix).map(removeEspecialChars).map(removeEspecialwords).filter(checkValid).map(prepare)
// remove duplicates
prepared = Array(Set(prepared))

struct LObjcFuntion {
    let o: String // origin
    let hname: String // header
    let impl: String // for implementation
}


// MARK: - converting to objc funtion names

let funtions = prepared.map { (key) -> LObjcFuntion in
    let name = "+ (NSString *)" + key.c
    let impl = name + " {\n" + "    return NSLocalizedString(@\"\(key.o)\", comment: @\"\(key.o)\");" + "\n" + "}"
    let lobjc = LObjcFuntion(o: key.o, hname: name + ";", impl: impl)
    return lobjc
}

struct Header {
    let headerfuncs: [String]
    func build() -> String {
        let l = "// --- generated by R.objc \n//*StringsResources.h*\n// This file contains strings from localizable.string file\n\n"
        let h = "#import <Foundation/Foundation.h>"
        let base = "@interface StringResources: NSObject"
        let end = "@end"
        let funcs = headerfuncs.joined(separator: NL)
        let all = l + h + NL + base + NL + funcs + NL + end + NL
        return all
    }
}

struct Implementation {
    let implfunctions: [String]
    func build() -> String {
        let l = "// --- generated by R.objc \n//*StringsResources.m*\n// This file contains strings from localizable.string file\n\n"
        let h = "#import \"StringsResources.h\""
        let base = "@implementation StringResources"
        let end = "@end"
        let funcs = implfunctions.joined(separator: NL)
        let all = l + h + NL + base + NL + funcs + NL + end + NL
        return all
    }
}

// MARK: - Finalize
let header = Header(headerfuncs: funtions.map({$0.hname}))
let implementation = Implementation(implfunctions: funtions.map({$0.impl}))

let hfile = fileManager.createFile(atPath: path + "/StringsResources.h", contents: header.build().data(using: .utf8)!, attributes: nil)
let ifile = fileManager.createFile(atPath: path + "/StringsResources.m", contents: implementation.build().data(using: .utf8)!, attributes: nil)

print("HORRAY COMPLETED")
